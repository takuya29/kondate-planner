AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Kondate Planner - Bedrock Agent for Meal Planning via Slack

Parameters:
  SlackWorkspaceId:
    Type: String
    Description: "Slack Workspace ID (get from AWS Chatbot console)"
    AllowedPattern: "^[0-9A-Z]{1,255}$"
    ConstraintDescription: "Must be a valid Slack workspace ID"

  SlackChannelId:
    Type: String
    Description: "Slack Channel ID (right-click channel > Copy Link, use last part of URL)"
    AllowedPattern: "^[A-Za-z0-9]+$"
    ConstraintDescription: "Must be a valid Slack channel ID"

  BedrockInferenceProfile:
    Type: String
    Description: "Bedrock inference profile ID (cross-region routing)"
    Default: "jp.anthropic.claude-sonnet-4-5-20250929-v1:0"

Globals:
  Function:
    Runtime: python3.12
    Timeout: 30
    MemorySize: 256
    Architectures:
      - arm64
    Layers:
      - !Ref CommonLayer
    Environment:
      Variables:
        RECIPES_TABLE: !Ref RecipesTable
        HISTORY_TABLE: !Ref MenuHistoryTable

Resources:
  # ==================== DynamoDB Tables ====================
  RecipesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: kondate-recipes
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: name
          AttributeType: S
        - AttributeName: category
          AttributeType: S
      KeySchema:
        - AttributeName: name
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: CategoryIndex
          KeySchema:
            - AttributeName: category
              KeyType: HASH
          Projection:
            ProjectionType: ALL

  MenuHistoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: kondate-menu-history
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: date
          AttributeType: S
      KeySchema:
        - AttributeName: date
          KeyType: HASH

  # ==================== Lambda Layer ====================
  CommonLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: kondate-common-layer
      ContentUri: src/layers/common/
      CompatibleRuntimes:
        - python3.12
      LicenseInfo: 'MIT'
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # ==================== Bedrock Agent Action Functions ====================
  GetRecipesActionFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/agent_actions/get_recipes/
      Handler: app.lambda_handler
      Description: Bedrock Agent action to retrieve recipes
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Ref RecipesTable

  GetHistoryActionFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/agent_actions/get_history/
      Handler: app.lambda_handler
      Description: Bedrock Agent action to retrieve menu history
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Ref MenuHistoryTable

  SaveMenuActionFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/agent_actions/save_menu/
      Handler: app.lambda_handler
      Description: Bedrock Agent action to save menu to history
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref MenuHistoryTable

  # ==================== Bedrock Agent ====================
  KondateAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: kondate-planner-agent
      AgentResourceRoleArn: !GetAtt BedrockAgentRole.Arn
      FoundationModel: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/${BedrockInferenceProfile}'
      Description: Meal planning assistant for Japanese recipes
      IdleSessionTTLInSeconds: 600
      AutoPrepare: true
      Instruction: |
        You are a helpful meal planning assistant that helps users create balanced Japanese meal plans.

        ⚠️ CRITICAL RULE - MUST FOLLOW BEFORE ALL OTHER INSTRUCTIONS ⚠️
        =================================================================
        YOU MUST NEVER INVENT OR CREATE RECIPE NAMES. PERIOD.

        EVERY recipe name you suggest MUST come from the get_recipes() action response.
        If a recipe name is not in the get_recipes() response, you CANNOT use it.

        STRICT MATCHING REQUIREMENTS:
        - Use the EXACT recipe name from get_recipes() - character-for-character match
        - Do NOT abbreviate, modify, or paraphrase recipe names
        - Do NOT use similar recipe names (e.g., if database has "鶏の照り焼き", don't use "照り焼きチキン")
        - Do NOT use generic recipe names based on your knowledge (e.g., "カレー", "味噌汁")
        - Even if a recipe name seems common or obvious, you MUST verify it exists in get_recipes()

        Before suggesting ANY menu:
        1. Call get_recipes() first
        2. Store the EXACT recipe names from the response (character-for-character)
        3. ONLY select from those exact names - no variations allowed
        4. Before presenting your menu to the user, verify EACH recipe name one-by-one against your stored list
        5. If you cannot verify a recipe exists with exact character match, REMOVE it from your suggestion

        Inventing recipes is a CRITICAL ERROR that breaks the application.
        When in doubt, use fewer recipes rather than inventing new ones.
        =================================================================

        AVAILABLE RECIPES AND HISTORY:
        - Call get_recipes() to see all available recipes. You can optionally filter by category.
        - Call get_history() to see recent menus (default 30 days). Use this to avoid repeating recipes.

        DATE CALCULATION AND COMMUNICATION:
        1. When user requests N days of menu planning:
           - Calculate the actual date range (format: YYYY-MM-DD internally, MM月DD日 to users)
           - Default start date is TODAY (current system date) unless user specifies otherwise
           - IMPORTANT: Calculate dates dynamically - do not assume a fixed reference date
           - Example: "3日分" on 2025-11-11 = Nov 11, 12, 13
           - CRITICAL: The date parameter format is strictly YYYY-MM-DD (e.g., "2025-11-11")
           - Do NOT use Japanese date formats (令和, 平成) or ambiguous formats (11/11) in API calls
           - Always display Japanese format (MM月DD日) to users, but use YYYY-MM-DD internally

        2. ALWAYS mention the date range at the start of your response:
           - Format: "MM月DD日からMM月DD日の献立を提案します"
           - Include day of week if helpful: "11月11日(月)から11月13日(水)"

        3. Handle relative dates:
           - "明日から" → Start from tomorrow
           - "今週" → Current week's remaining days
           - "来週" → Next week Monday-Friday (or all 7 days if weekend mentioned)

        MEAL PLANNING RULES:
        When generating menu suggestions:
        1. Breakfast: SKIP unless user explicitly requests it (user rarely cooks breakfast)
        2. Lunch: 1-3 dishes (balanced meal or bento-style)
        3. Dinner: 2-3 dishes (main + side + soup is common) - FOCUS ON THIS
        4. Variety across meals: Don't repeat the same main protein on consecutive days
        5. Ingredient efficiency: Prefer recipes that share common ingredients to minimize shopping
           - Example: If one recipe uses 鶏肉, suggest another 鶏肉 recipe for a different day
           - Balance efficiency with variety - don't use the exact same ingredients for all meals
        6. Balance: Include vegetables in dinner when possible
        7. Weekend vs weekday: Automatically adjust complexity (weekends = more elaborate recipes OK)
        8. Available categories (from actual database):
           - メイン (main dishes: meat, fish, noodles)
           - 汁物 (soups: miso soup, consommé)
           - その他 (other: sides, rice, misc)
           - サラダ (salads)
           - 副菜 (side dishes)

        RESPONSE FORMAT (IMPORTANT - For Slack compatibility):
        - Keep responses concise and well-structured
        - Use this compact format for menu suggestions WITH DATES:
          **11月11日 (月):**
          - 朝食: レシピ名1, レシピ名2
          - 昼食: レシピ名1, レシピ名2
          - 夕食: レシピ名1, レシピ名2, レシピ名3
        - Avoid repeating detailed recipe information (ingredients, cooking time, etc.)
        - Focus on recipe names and categories only
        - Keep additional commentary brief

        WORKFLOW:
        1. When user asks for menu suggestions:
           a. Calculate the target date range based on user request
           b. Call get_history() with enough days to cover the target range
              EXAMPLE: If user asks for "3日分" starting Nov 11, call get_history(days=3)
              or get_history() without parameters to fetch 30 days (recommended for better context)
           c. Check if ANY of the target dates already have saved menus

        2. If existing menus found on target dates:
           - Display which dates have existing menus
           - Show the existing menu details for each conflicting date:
             "既に献立が登録されている日があります：

             **11月11日:**
             - 昼食: レシピ名1, レシピ名2
             - 夕食: レシピ名1, レシピ名2, レシピ名3
             (朝食は省略 - only show if breakfast exists in the data)

             新しい献立を提案しますか？"
           - Wait for user confirmation before proceeding

        3. Generate menu plan:
           - Fetch recipes with get_recipes() and store the complete list
           - CRITICAL VERIFICATION PROCESS (YOU MUST DO THIS):
             a. FIRST: Internally enumerate ALL recipe names from get_recipes() response
                Example: "Available recipes: [Recipe A, Recipe B, Recipe C, ...]"
             b. SECOND: For each day, select recipes ONLY from that enumerated list
             c. THIRD: Before presenting to user, do a final verification:
                - Go through your suggested menu line by line
                - Check if each recipe name exists EXACTLY in the get_recipes() list
                - If a recipe name is NOT in the list, REMOVE it immediately
                - If uncertain about a recipe name, DO NOT USE IT
                - It is better to suggest fewer recipes than to risk inventing recipes
           - Avoid recipes used in recent history (past 7 days)
           - Create balanced menu for requested days using ONLY verified recipes
           - Mention the date range: "MM月DD日からMM月DD日の献立を提案します"

        4. FINAL SANITY CHECK (before presenting to user):
           - Review your menu one last time
           - Confirm EVERY recipe name is from get_recipes() response
           - If you have ANY doubt about a recipe name, remove it
           - Ask yourself: "Did I get this recipe name from get_recipes()?"
           - If the answer is "maybe" or "I think so", DO NOT use that recipe

        5. Present the menu with specific dates (skip breakfast unless user explicitly requested it):
           **MM月DD日 (Day of week):**
           - 昼食: レシピ名1, レシピ名2
           - 夕食: レシピ名1, レシピ名2, レシピ名3

           (Only include breakfast line if user explicitly asked for breakfast suggestions)

        6. Ask: "この献立で保存しますか？"

        7. On confirmation:
           - When saving multiple days (e.g., 3-day menu):
             * Call save_menu() once for EACH date (3 separate calls)
             * Save sequentially, not in parallel
             * If ANY save fails with error 409, STOP and show user which dates have conflicts
             * Format: "11月11日と11月12日は保存できましたが、11月13日には既に献立があります。[show existing menu for 11月13日]"
             * Ask user: "11月13日を上書きしますか？それとも別の日付にしますか？"
           - IMPORTANT: When calling save_menu(), you MUST provide the date parameter in YYYY-MM-DD format
           - For today's menu, use today's date (current system date)
           - For future menus, use the appropriate future date
           - Example: save_menu(date="2025-11-11", meals={...})
           - If duplicate error (409): Ask about overwrite with overwrite=true
           - Confirm success for each saved date

        HANDLING DUPLICATE DATES:
        - If save_menu() returns error "duplicate_date" (status 409), a menu already exists for that date
        - IMPORTANT: You MUST display the existing menu to the user before asking for confirmation
        - Format the existing menu clearly showing what's already registered:
          "この日には既に以下の献立が登録されています：
          - 朝食: レシピ名1, レシピ名2
          - 昼食: レシピ名1, レシピ名2
          - 夕食: レシピ名1, レシピ名2, レシピ名3

          上書きしますか？"
        - The existing menu details are in the error response's "existing_menu" field
        - If user confirms overwrite, call save_menu() again with overwrite=true parameter
        - If user declines, do not save and suggest picking a different date
        - Example: save_menu(date="2025-11-11", meals={...}, overwrite=true)

        ERROR HANDLING:
        - If get_recipes() fails: Apologize and explain you cannot access recipe database
        - If get_history() fails: Warn user you cannot check for duplicates, ask if they want to proceed
        - If save_menu() fails (non-409 error): Report the error and offer to retry
        - Never proceed with incomplete data - always inform the user of limitations

        EDGE CASES:
        - Empty recipe database: Inform user no recipes available, cannot plan menus
        - User requests >7 days: Warn about repetition likelihood, suggest smaller batches
        - No breakfast preference: Default to simple Japanese breakfast (rice, miso soup, pickles)
        - History shows user never eats breakfast: Ask if they want breakfast suggestions

        CONTEXT AND INSIGHTS:
        - When appropriate, mention why you chose certain recipes:
          - Seasonal ingredients (e.g., "秋なので、きのこ料理を入れました")
          - Balance correction (e.g., "最近肉が多かったので、魚料理を中心に")
          - Variety (e.g., "和洋中のバランスを考えました")
          - Weekend consideration (e.g., "週末なので、少し手の込んだレシピを入れました")
        - Keep insights brief (1 sentence max)
        - Only add context if it genuinely helps the user

        EXAMPLE CONVERSATIONS:

        Example 1 - Standard Flow:
        User: "3日分の献立をお願いします"
        Agent:
        1. Call get_history(days=30)
        2. Call get_recipes() - receive list of recipes
        3. Internal verification: Check each recipe name against the get_recipes() response
           - ONLY include recipes that exist in the response
           - Remove any recipe that is not in the list
        4. Check if Nov 11-13 have existing menus (none found)
        5. Response: "11月11日から11月13日の献立を提案します。
           **11月11日(月):**
           - 昼食: [verified recipe from database]
           - 夕食: [verified recipe 1], [verified recipe 2]

           **11月12日(火):**
           - 昼食: [verified recipe from database]
           - 夕食: [verified recipe 1], [verified recipe 2]

           **11月13日(水):**
           - 昼食: [verified recipe from database]
           - 夕食: [verified recipe 1], [verified recipe 2]

           この献立で保存しますか？"

        CRITICAL: Replace [verified recipe from database] with ONLY recipe names that exist in your get_recipes() response.

        Example 2 - WRONG WAY (DO NOT DO THIS):
        User: "3日分の献立をお願いします"
        Agent: ❌ WRONG - Suggests recipes WITHOUT calling get_recipes() first
        Agent: ❌ WRONG - Invents recipe names that may not exist in database
        Agent: ❌ WRONG - Suggests recipes based on general knowledge instead of database

        WHY THIS IS WRONG: The user cannot cook these recipes because they don't exist in the recipe database. This breaks the application.

        CORRECT APPROACH: ALWAYS call get_recipes() first, then ONLY suggest recipes from the response.

        Example 3 - Conflict Detected:
        User: "明日の献立を提案して"
        Agent:
        1. Call get_history(days=30)
        2. Find existing menu for tomorrow (Nov 12)
        3. Response: "11月12日には既に以下の献立が登録されています：
           - 朝食: 味噌汁、納豆
           - 昼食: カレーライス
           - 夕食: 焼き魚、サラダ

           新しい献立を提案しますか？"

        TONE:
        - Be friendly and conversational
        - Respond in Japanese or English based on user's language
        - Provide brief cooking tips or nutritional insights when relevant
      ActionGroups:
        - ActionGroupName: GetRecipes
          Description: Retrieve recipes from database - MUST call before suggesting any menu
          ActionGroupExecutor:
            Lambda: !GetAtt GetRecipesActionFunction.Arn
          ApiSchema:
            Payload: |
              openapi: 3.0.0
              info:
                title: Get Recipes API
                version: 1.0.0
                description: Retrieve recipes from DynamoDB. CRITICAL - You must ONLY suggest recipes returned by this API. Never invent recipe names.
              paths:
                /get-recipes:
                  post:
                    summary: Get recipes
                    description: Retrieve all available recipes. MUST be called before suggesting menus. Only recipes returned by this endpoint can be suggested to users. Filter by category (主菜, 副菜, 汁物, etc.) if needed.
                    operationId: getRecipes
                    requestBody:
                      required: false
                      content:
                        application/json:
                          schema:
                            type: object
                            properties:
                              category:
                                type: string
                                description: Optional category filter (e.g., 主菜, 副菜, 汁物)
                    responses:
                      '200':
                        description: Successful response
                        content:
                          application/json:
                            schema:
                              type: object
                              properties:
                                recipes:
                                  type: array
                                  items:
                                    type: object
                                    properties:
                                      name:
                                        type: string
                                      category:
                                        type: string
                                      ingredients:
                                        type: array
                                        items:
                                          type: string
                                      recipe_url:
                                        type: string
        - ActionGroupName: GetHistory
          Description: Retrieve menu history
          ActionGroupExecutor:
            Lambda: !GetAtt GetHistoryActionFunction.Arn
          ApiSchema:
            Payload: |
              openapi: 3.0.0
              info:
                title: Get Menu History API
                version: 1.0.0
                description: Retrieve menu history for the past N days
              paths:
                /get-history:
                  post:
                    summary: Get menu history
                    description: Retrieve menu history for past N days (default 30, max 365). Use this to avoid repeating recent recipes.
                    operationId: getHistory
                    requestBody:
                      required: false
                      content:
                        application/json:
                          schema:
                            type: object
                            properties:
                              days:
                                type: integer
                                description: Number of days to retrieve (1-365, default 30)
                                minimum: 1
                                maximum: 365
                    responses:
                      '200':
                        description: Successful response
                        content:
                          application/json:
                            schema:
                              type: object
                              properties:
                                history:
                                  type: array
                                  items:
                                    type: object
                                    properties:
                                      date:
                                        type: string
                                        format: date
                                      meals:
                                        type: object
                                        properties:
                                          breakfast:
                                            type: array
                                            items:
                                              type: string
                                          lunch:
                                            type: array
                                            items:
                                              type: string
                                          dinner:
                                            type: array
                                            items:
                                              type: string
                                      recipes:
                                        type: array
                                        items:
                                          type: string
                                        description: Flat list of all recipe names used this day
                                      notes:
                                        type: string
        - ActionGroupName: SaveMenu
          Description: Save approved menus with verified recipes only
          ActionGroupExecutor:
            Lambda: !GetAtt SaveMenuActionFunction.Arn
          ApiSchema:
            Payload: |
              openapi: 3.0.0
              info:
                title: Save Menu API
                version: 1.0.0
                description: Save a confirmed menu plan to history. Only save recipes that were returned by get_recipes() API.
              paths:
                /save-menu:
                  post:
                    summary: Save menu
                    description: Save a menu plan to history. ONLY call this after user explicitly confirms (yes/はい/保存して/looks good). Ensure all recipe names in the menu were returned by get_recipes() before saving.
                    operationId: saveMenu
                    requestBody:
                      required: true
                      content:
                        application/json:
                          schema:
                            type: object
                            required:
                              - date
                              - meals
                            properties:
                              date:
                                type: string
                                format: date
                                description: Date in YYYY-MM-DD format
                              meals:
                                type: object
                                required:
                                  - breakfast
                                  - lunch
                                  - dinner
                                properties:
                                  breakfast:
                                    type: array
                                    items:
                                      type: string
                                  lunch:
                                    type: array
                                    items:
                                      type: string
                                  dinner:
                                    type: array
                                    items:
                                      type: string
                              notes:
                                type: string
                                description: Optional notes about this menu
                              overwrite:
                                type: boolean
                                description: Set to true to overwrite existing menu for this date. Default is false. If false and menu exists, returns error with existing menu details.
                    responses:
                      '200':
                        description: Successful response
                        content:
                          application/json:
                            schema:
                              type: object
                              properties:
                                success:
                                  type: boolean
                                date:
                                  type: string
                                overwritten:
                                  type: boolean
                                  description: True if an existing menu was overwritten
                                message:
                                  type: string
                      '409':
                        description: Menu already exists for this date (overwrite not confirmed)
                        content:
                          application/json:
                            schema:
                              type: object
                              properties:
                                success:
                                  type: boolean
                                error:
                                  type: string
                                  description: Error code (duplicate_date)
                                date:
                                  type: string
                                existing_menu:
                                  type: object
                                  description: The existing menu data for this date
                                message:
                                  type: string

  KondateAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !GetAtt KondateAgent.AgentId
      AgentAliasName: production
      Description: Production alias with inference profile support

  # ==================== Amazon Q Developer / Chatbot ====================
  DeveloperQSlackChannel:
    Type: AWS::Chatbot::SlackChannelConfiguration
    Properties:
      ConfigurationName: kondate-developer-q-channel
      IamRoleArn: !GetAtt AmazonQChatbotRole.Arn
      SlackWorkspaceId: !Ref SlackWorkspaceId
      SlackChannelId: !Ref SlackChannelId
      LoggingLevel: INFO
      GuardrailPolicies:
        - !Ref InvokeBedrockAgentPolicy

  # ==================== Amazon Q / Chatbot IAM Role ====================
  AmazonQChatbotRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: kondate-amazonq-chatbot-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: chatbot.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchLogsReadOnlyAccess
        - !Ref InvokeBedrockAgentPolicy

  # ==================== Shared Bedrock Agent Policy ====================
  InvokeBedrockAgentPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: kondate-invoke-bedrock-agent-policy
      Description: Allow invocation of Bedrock Agent (used by both channel role and guardrail)
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - bedrock:InvokeAgent
              - bedrock:GetAgent
              - bedrock:ListAgents
            Resource:
              - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'
              - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/*/*'

  # ==================== Bedrock Agent IAM Role ====================
  BedrockAgentRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: kondate-bedrock-agent-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
      Policies:
        - PolicyName: InvokeActionLambdas
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt GetRecipesActionFunction.Arn
                  - !GetAtt GetHistoryActionFunction.Arn
                  - !GetAtt SaveMenuActionFunction.Arn
        - PolicyName: InvokeFoundationModel
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:GetInferenceProfile
                  - bedrock:GetFoundationModel
                Resource:
                  # Allow any inference profile in this account
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*'
                  # Allow any foundation model in any region
                  # Note: Cross-region inference profiles may invoke models in other regions
                  - 'arn:aws:bedrock:*::foundation-model/*'

  # ==================== Lambda Resource-based Policies (Allow Bedrock to invoke) ====================
  GetRecipesActionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetRecipesActionFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceAccount: !Ref AWS::AccountId

  GetHistoryActionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetHistoryActionFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceAccount: !Ref AWS::AccountId

  SaveMenuActionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SaveMenuActionFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceAccount: !Ref AWS::AccountId

Outputs:
  # ==================== DynamoDB ====================
  RecipesTableName:
    Description: "DynamoDB Recipes table name"
    Value: !Ref RecipesTable

  MenuHistoryTableName:
    Description: "DynamoDB Menu History table name"
    Value: !Ref MenuHistoryTable

  # ==================== Lambda Functions ====================
  GetRecipesActionFunctionArn:
    Description: "ARN of GetRecipesAction Lambda"
    Value: !GetAtt GetRecipesActionFunction.Arn

  GetHistoryActionFunctionArn:
    Description: "ARN of GetHistoryAction Lambda"
    Value: !GetAtt GetHistoryActionFunction.Arn

  SaveMenuActionFunctionArn:
    Description: "ARN of SaveMenuAction Lambda"
    Value: !GetAtt SaveMenuActionFunction.Arn

  # ==================== Bedrock Agent ====================
  BedrockAgentId:
    Description: "Bedrock Agent ID"
    Value: !GetAtt KondateAgent.AgentId

  BedrockAgentArn:
    Description: "Bedrock Agent ARN"
    Value: !GetAtt KondateAgent.AgentArn

  BedrockAgentAliasId:
    Description: "Bedrock Agent Alias ID (production)"
    Value: !GetAtt KondateAgentAlias.AgentAliasId

  BedrockAgentAliasArn:
    Description: "Bedrock Agent Alias ARN (use this in AWS Chatbot)"
    Value: !GetAtt KondateAgentAlias.AgentAliasArn

  # ==================== IAM Roles ====================
  AmazonQChatbotRoleArn:
    Description: "IAM Role ARN for Amazon Q / Chatbot"
    Value: !GetAtt AmazonQChatbotRole.Arn

  BedrockAgentRoleArn:
    Description: "IAM Role ARN for Bedrock Agent"
    Value: !GetAtt BedrockAgentRole.Arn

  # ==================== Developer Q / Chatbot ====================
  DeveloperQSlackChannelArn:
    Description: "Developer Q Slack Channel Configuration ARN"
    Value: !Ref DeveloperQSlackChannel

  InvokeBedrockAgentPolicyArn:
    Description: "Bedrock Agent invocation policy ARN (used by both role and guardrail)"
    Value: !Ref InvokeBedrockAgentPolicy

  # ==================== Model Configuration ====================
  CurrentInferenceProfile:
    Description: "Current inference profile"
    Value: !Ref BedrockInferenceProfile

  InferenceProfileArn:
    Description: "Full ARN of the inference profile being used"
    Value: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/${BedrockInferenceProfile}'
